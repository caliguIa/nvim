local has_artisan_command = false
local artisan_cmds_cache = nil

local function get_artisan_cmds()
    local commands = {}

    local function append_cmd(cmd, prefix)
        local handle = io.popen(cmd)
        if not handle then return end

        local output = handle:read("*a")
        handle:close()

        local success, decoded = pcall(vim.json.decode, output)
        if not success or not decoded.commands then return end

        for _, cmd_data in ipairs(decoded.commands) do
            local command_name = cmd_data.name
            if command_name ~= "_complete" and command_name ~= "completion" then
                table.insert(commands, prefix .. command_name)
            end
        end
    end

    append_cmd("php artisan list --format=json --short", "")

    return commands
end

local function run_cmd(opts)
    vim.cmd("vsplit")
    vim.cmd("wincmd L")
    vim.cmd("vertical resize " .. math.floor(vim.o.columns * 0.3))
    vim.cmd.terminal("artisan " .. table.concat(opts.fargs, " "))
    local buf = vim.api.nvim_get_current_buf()
    vim.bo[buf].buflisted = false
    vim.schedule(function()
        vim.keymap.set("n", "q", function()
            vim.cmd("close")
            pcall(vim.api.nvim_buf_delete, buf, { force = true })
        end, {
            buffer = buf,
            silent = true,
            desc = "Quit Laravel terminal",
        })
    end)
end

local function try_create_artisan_command()
    local is_laravel_project = vim.fn.filereadable("./artisan") == 1 and vim.fn.filereadable("./composer.json") == 1

    if is_laravel_project and not has_artisan_command then
        vim.api.nvim_create_user_command("Artisan", run_cmd, {
            desc = "Shorthand for running Artisan commands in a terminal buffer",
            nargs = "*",
            complete = function()
                if not artisan_cmds_cache then artisan_cmds_cache = get_artisan_cmds() end
                return artisan_cmds_cache
            end,
        })

        has_artisan_command = true
    elseif not is_laravel_project and has_artisan_command then
        pcall(vim.api.nvim_del_user_command, "Artisan")
        has_artisan_command = false
    end
end

try_create_artisan_command()

vim.api.nvim_create_user_command("ArtisanCacheClear", function()
    artisan_cmds_cache = nil
    vim.notify("Cleared Artisan command cache")
end, {
    desc = "Clears the cache of commands generated by :Artisan",
    nargs = 0,
})

vim.api.nvim_create_autocmd("DirChanged", {
    group = vim.api.nvim_create_augroup("artisan-command", { clear = true }),
    callback = try_create_artisan_command,
})
